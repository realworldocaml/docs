<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Soup (lambdasoup.Soup)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> â€“ package <a href="../index.html">lambdasoup</a></nav><h1>Module <code>Soup</code></h1><p>Easy functional HTML scraping and manipulation.</p><p>Lambda Soup is an HTML data extraction and analysis library. It supports CSS selectors, DOM traversals, mutation, and HTML output. This very documentation page was generated by <code>ocamldoc</code> and then <a href="https://github.com/aantron/lambda-soup/blob/master/docs/postprocess.ml">rewritten</a> by Lambda Soup!</p><p>Here are some usage examples:</p><pre><code>open Soup

let soup = read_channel stdin |&gt; parse in

(* Print the page title. *)
soup $ &quot;title&quot; |&gt; R.leaf_text |&gt; print_endline;

(* Print the targets of all links. *)
soup $$ &quot;a[href]&quot;
|&gt; iter (fun a -&gt; print_endline (R.attribute &quot;href&quot; a));

(* Find the first unordered list. *)
let ul = soup $ &quot;ul&quot; in

(* Print the contents of all its items. *)
ul $$ &quot;li&quot;
|&gt; iter (fun li -&gt;
  trimmed_texts li |&gt; String.concat &quot;&quot; |&gt; print_endline)

(* Find all subsequent sibling elements of the same list. *)
let _ = ul $$ &quot;~ *&quot; in

(* Find all previous sibling elements instead. *)
let _ = ul |&gt; previous_siblings |&gt; elements in

(* ... *)</code></pre><p>Lambda Soup is based around two kind of values: <em>nodes</em>, which represent HTML elements, text content, and so on, and <em>traversals</em>, which are lazy sequences of nodes. The top-level node is the <em>soup node</em> (a.k.a. document node), which you typically get by calling <a href="index.html#val-parse"><code>parse</code></a> on a string containing HTML.</p><p>Once you have a node, you call <a href="index.html#val-select"><code>select</code></a> on it to traverse to other nodes using CSS. There are also specialized functions, such as <a href="index.html#val-ancestors"><code>ancestors</code></a> and <a href="index.html#val-previous_siblings"><code>previous_siblings</code></a>, which allow you to traverse in directions that CSS cannot express.</p><p>Traversals can be manipulated with familiar combinators such as <a href="index.html#val-map"><code>map</code></a>, <a href="index.html#val-fold"><code>fold</code></a>, and <a href="index.html#val-filter"><code>filter</code></a>. They can also be terminated early.</p><p>Once you have traversed to a node you are interested in, you can extract its content or attributes, mutate it, cause other side effects, begin another traversal, or do anything else your application requires. Enjoy!</p><p>Lambda Soup is developed on <a href="https://github.com/aantron/lambda-soup">GitHub</a> and distributed under the <a href="https://github.com/aantron/lambda-soup/blob/master/LICENSE.md">BSD license</a>.</p><p>This documentation page is for version 0.6.2 of the library. Documentation for other versions can be downloaded from the <a href="https://github.com/aantron/lambda-soup/releases">releases page</a>.</p><nav><ul><li><a href="#types">Types</a></li><li><a href="#high-level-interface">High-level interface</a></li><li><a href="#options">Options</a></li><li><a href="#early-termination">Early termination</a></li><li><a href="#element-access">Element access</a></li><li><a href="#content-access">Content access</a></li><li><a href="#elementary-traversals">Elementary traversals</a></li><li><a href="#combinators">Combinators</a></li><li><a href="#projection">Projection</a></li><li><a href="#convenience">Convenience</a></li><li><a href="#printing">Printing</a></li><li><a href="#parsing-signals">Parsing signals</a></li><li><a href="#equality">Equality</a></li><li><a href="#mutation">Mutation</a></li><li><a href="#i/o">I/O</a></li></ul></nav></header><section><header><h2 id="types"><a href="#types" class="anchor"></a>Types</h2></header><dl><dt id="type-element"><a href="#type-element" class="anchor"></a><code><span class="keyword">type </span>element</code><code></code><code></code></dt><dt id="type-general"><a href="#type-general" class="anchor"></a><code><span class="keyword">type </span>general</code><code></code><code></code></dt><dt id="type-soup"><a href="#type-soup" class="anchor"></a><code><span class="keyword">type </span>soup</code><code></code><code></code></dt><dd><p>&quot;Phantom&quot; types for use with <code>'a node</code>. See explanation below.</p></dd></dl><dl><dt id="type-node"><a href="#type-node" class="anchor"></a><code><span class="keyword">type </span>'a node</code><code></code><code></code></dt><dd><p>HTML nodes. These come in three varieties: <code>element node</code> represents a node that is known to be an element, <code>soup node</code> represents an entire document, and <code>general node</code> represents a node that might be anything, including an element, a document, or text. There is no phantom type specifically for text nodes.</p><p>Throughout Lambda Soup, if a function can operate on any kind of node, the argument is typed at <code>'a node</code>. If an element node or the entire document is required, the argument type is <code>element node</code> or <code>soup node</code>, respectively. <code>general node</code> is the result of a function that can't guarantee that it evaluates to only elements or only documents.</p></dd></dl><dl><dt id="type-nodes"><a href="#type-nodes" class="anchor"></a><code><span class="keyword">type </span>'a nodes</code><code></code><code></code></dt><dd><p>Sequence of nodes. This is always instantiated as either <code>element nodes</code> or or <code>general nodes</code>. The sequence is <em>lazy</em> in the sense that only as many elements as needed are evaluated. This can be used with <a href="index.html#val-with_stop"><code>with_stop</code></a> to traverse part of a document until some condition is met.</p></dd></dl></section><section><header><h2 id="high-level-interface"><a href="#high-level-interface" class="anchor"></a>High-level interface</h2></header><dl><dt id="val-parse"><a href="#val-parse" class="anchor"></a><code><span class="keyword">val </span>parse : string <span>&#8209;&gt;</span> <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Parses the given HTML and produces a document node. Entity references are resolved. The character encoding is detected automatically.</p><p>If you need to parse XML, want finer control over parsing, or want to feed Lambda Soup something other than bytes, see <a href="#2_Parsingsignals">Parsing signals</a>.</p></dd></dl><dl><dt id="val-select"><a href="#val-select" class="anchor"></a><code><span class="keyword">val </span>select : string <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>select selector node</code> is all the descendants of <code>node</code> matching CSS selector <code>selector</code>. All <a href="http://www.w3.org/TR/selectors/#selectors">CSS3 selectors</a> are supported, except those which imply layout or a user interface:</p><pre><code>:link, :visited, :hover, :active, :focus, :target, :lang, :enabled,
:disabled, :checked, :indeterminate, ::first-line, ::first-letter,
::selection, ::before, ::after</code></pre><p>XML namespace selectors are not supported. Lambda Soup supports the canceled <a href="http://www.w3.org/TR/2001/CR-css3-selectors-20011113/#content-selectors"><code>:contains(&quot;foo&quot;)</code></a> pseudo-class.</p><p>In regular CSS, a selector cannot start with a combinator such as <code>&gt;</code>. Lambda Soup allows selectors such as <code>&gt; p</code>, <code>+ p</code>, and <code>~ p</code>, which select immediate children of <code>node</code>, adjacent next siblings, and all next siblings, respectively.</p><p>In addition, you can use the empty selector to select <code>node</code> itself. In this case, note that if <code>node</code> is not an element (for example, it is often the soup node), <code>select</code> will result in nothing: <code>select</code> always results in sequences of <em>element</em> nodes only.</p></dd></dl><dl><dt id="val-select_one"><a href="#val-select_one" class="anchor"></a><code><span class="keyword">val </span>select_one : string <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <code>select</code>, but evaluates to at most one element. Note that there is also <code>R.select_one</code> if you don't want an optional result, which is explained at <a href="index.html#val-require"><code>require</code></a>.</p></dd></dl><dl><dt id="val-($$)"><a href="#val-($$)" class="anchor"></a><code><span class="keyword">val </span>($$) : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>node $$ selector</code> is the same as <code>select selector node</code>.</p></dd></dl><dl><dt id="val-($?)"><a href="#val-($?)" class="anchor"></a><code><span class="keyword">val </span>($?) : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>node $? selector</code> is the same as <code>select_one selector node</code>.</p></dd></dl><dl><dt id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val </span>($) : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a></code></dt><dd><p><code>node $ selector</code> is the same as <code>select_one selector node |&gt; require</code>.</p></dd></dl><article id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module </span><a href="Infix/index.html">Infix</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article></section><section><header><h2 id="options"><a href="#options" class="anchor"></a>Options</h2></header><dl><dt id="val-require"><a href="#val-require" class="anchor"></a><code><span class="keyword">val </span>require : <span class="type-var">'a</span> option <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>require (Some v)</code> evaluates to <code>v</code>, and <code>require None</code> raises <code>Failure</code>.</p></dd></dl><article id="module-R"><a href="#module-R" class="anchor"></a><code><span class="keyword">module </span><a href="R/index.html">R</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></article></section><section><header><h2 id="early-termination"><a href="#early-termination" class="anchor"></a>Early termination</h2></header><dl><dt id="type-stop"><a href="#type-stop" class="anchor"></a><code><span class="keyword">type </span>'a stop</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-stop.throw" class="anchored"><td class="def field"><a href="#type-stop.throw" class="anchor"></a><code>throw : b. <span class="type-var">'a</span> <span>&#8209;&gt;</span> <span class="type-var">'b</span>;</code></td></tr></table><code>}</code><code></code></dt><dd><p>Used for early termination. See <a href="index.html#val-with_stop"><code>with_stop</code></a> below.</p></dd></dl><dl><dt id="val-with_stop"><a href="#val-with_stop" class="anchor"></a><code><span class="keyword">val </span>with_stop : (<span class="type-var">'a</span> <a href="index.html#type-stop">stop</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span>) <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_stop (fun stop -&gt; e)</code> behaves as <code>e</code>. However, if the evaluation of <code>e</code> calls <code>stop.throw v</code>, the whole expression immediately evaluates to <code>v</code> instead.</p><p>For example, here is an expression that finds the first node with a <code>draggable</code> attribute, stopping traversal immediately when that occurs:</p><pre><code>with_stop (fun stop -&gt;
  some_root_node
  |&gt; descendants
  |&gt; elements
  |&gt; iter (fun element -&gt;
    if has_attribute &quot;draggable&quot; element then
      stop.throw (Some element));
  None)</code></pre></dd></dl></section><section><header><h2 id="element-access"><a href="#element-access" class="anchor"></a>Element access</h2></header><dl><dt id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val </span>name : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string</code></dt><dd><p>The element's tag name. For example, an <code>&lt;a&gt;</code> element has tag name <code>a</code>. All tag names are converted to lowercase.</p></dd></dl><dl><dt id="val-attribute"><a href="#val-attribute" class="anchor"></a><code><span class="keyword">val </span>attribute : string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string option</code></dt><dd><p><code>attribute attr element</code> retrieves the value of attribute <code>attr</code> from the given element.</p></dd></dl><dl><dt id="val-classes"><a href="#val-classes" class="anchor"></a><code><span class="keyword">val </span>classes : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string list</code></dt><dd><p>The element's class list. For example, <code>&lt;a class=&quot;foo bar&quot;&gt;</code> has class list <code>[&quot;foo&quot;; &quot;bar&quot;]</code>.</p></dd></dl><dl><dt id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val </span>id : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string option</code></dt><dd><p>The element's id.</p></dd></dl><dl><dt id="val-has_attribute"><a href="#val-has_attribute" class="anchor"></a><code><span class="keyword">val </span>has_attribute : string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p><code>has_attribute attr element</code> indicates whether <code>element</code> has attribute <code>attr</code>.</p></dd></dl><dl><dt id="val-fold_attributes"><a href="#val-fold_attributes" class="anchor"></a><code><span class="keyword">val </span>fold_attributes : (<span class="type-var">'a</span> <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> <span class="type-var">'a</span>) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_attributes f init element</code> applies <code>f</code> successively to the names and values of the attributes of <code>element</code>. The first <code>string</code> argument to <code>f</code> is the attribute name, and the second is the value.</p></dd></dl><dl><dt id="val-element"><a href="#val-element" class="anchor"></a><code><span class="keyword">val </span>element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Given any node, asserts that it is an element <code>e</code>. If so, evaluates to <code>Some e</code>. Otherwise, evaluates to <code>None</code>.</p></dd></dl><dl><dt id="val-elements"><a href="#val-elements" class="anchor"></a><code><span class="keyword">val </span>elements : <span class="type-var">_</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Filters non-elements from a sequence of nodes.</p></dd></dl><dl><dt id="val-is_element"><a href="#val-is_element" class="anchor"></a><code><span class="keyword">val </span>is_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node is an element.</p></dd></dl></section><section><header><h2 id="content-access"><a href="#content-access" class="anchor"></a>Content access</h2></header><dl><dt id="val-texts"><a href="#val-texts" class="anchor"></a><code><span class="keyword">val </span>texts : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string list</code></dt><dd><p><code>texts node</code> is the content of all text nodes that are descendants of <code>node</code>. If <code>node</code> is itself a text node, evaluates to <code>node</code>'s content.</p></dd></dl><dl><dt id="val-trimmed_texts"><a href="#val-trimmed_texts" class="anchor"></a><code><span class="keyword">val </span>trimmed_texts : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string list</code></dt><dd><p>Same as <a href="index.html#val-texts"><code>texts</code></a>, but all strings are passed through <code>String.trim</code>, and then all empty strings are filtered out.</p></dd></dl><dl><dt id="val-leaf_text"><a href="#val-leaf_text" class="anchor"></a><code><span class="keyword">val </span>leaf_text : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string option</code></dt><dd><p><code>leaf_text node</code> retrieves the content of one text node in <code>node</code>:</p><ul><li>If <code>node</code> is a text node itself, with value <code>s</code>, <code>leaf_text node</code> evaluates to <code>Some s</code>.</li><li>If <code>node</code> is an element or soup node, then, <code>leaf_text node</code> filters out all text children of <code>node</code> containing only whitespace. If there is only one child <code>child</code> remaining, it evaluates to <code>leaf_text child</code>. If there are no children remaining, it evaluates to <code>Some &quot;&quot;</code>. If there are two or more children remaining, it evaluates to <code>None</code>.</li></ul><p>Here are some examples of what <code>leaf_text</code> produces for various nodes:</p><pre><code>some text                                =&gt;   Some &quot;some text&quot;
&lt;p&gt;some text&lt;/p&gt;                         =&gt;   Some &quot;some text&quot;
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;              =&gt;   Some &quot;some text&quot;
&lt;div&gt; &lt;p&gt;some text&lt;/p&gt;&lt;/div&gt;             =&gt;   Some &quot;some text&quot;
&lt;div&gt;&lt;p&gt;some text&lt;/p&gt;&lt;p&gt;more&lt;/p&gt;&lt;/div&gt;   =&gt;   None
&lt;div&gt;&lt;/div&gt;                              =&gt;   Some &quot;&quot;</code></pre></dd></dl></section><section><header><h2 id="elementary-traversals"><a href="#elementary-traversals" class="anchor"></a>Elementary traversals</h2></header><dl><dt id="val-children"><a href="#val-children" class="anchor"></a><code><span class="keyword">val </span>children : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>children node</code> is the sequence of all children of <code>node</code>. If <code>node</code> is a text node, the traversal is empty.</p></dd></dl><dl><dt id="val-descendants"><a href="#val-descendants" class="anchor"></a><code><span class="keyword">val </span>descendants : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>descendants node</code> is the sequence of all descendants of <code>node</code>. <code>node</code> is not considered to be its own descendant. If <code>node</code> is a text node, the traversal is empty.</p></dd></dl><dl><dt id="val-ancestors"><a href="#val-ancestors" class="anchor"></a><code><span class="keyword">val </span>ancestors : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>ancestors node</code> is the sequence of all ancestors of <code>node</code>. <code>node</code> is not considered to be its own ancestor. The soup node is not included. Ancestors are ordered by proximity to <code>node</code>, i.e. the sequence goes up the DOM tree to a root element.</p></dd></dl><dl><dt id="val-siblings"><a href="#val-siblings" class="anchor"></a><code><span class="keyword">val </span>siblings : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>siblings node</code> is the sequence of all siblings of <code>node</code>. <code>node</code> is not considered to be its own sibling. The siblings are ordered as they appear in the child list of <code>node</code>'s parent.</p></dd></dl><dl><dt id="val-next_siblings"><a href="#val-next_siblings" class="anchor"></a><code><span class="keyword">val </span>next_siblings : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Like <a href="index.html#val-siblings"><code>siblings</code></a>, but only those siblings which follow <code>node</code> in its parent's child list.</p></dd></dl><dl><dt id="val-previous_siblings"><a href="#val-previous_siblings" class="anchor"></a><code><span class="keyword">val </span>previous_siblings : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Like <a href="index.html#val-siblings"><code>siblings</code></a>, but only those siblings which precede <code>node</code> in its parent's child list, and ordered by proximity to <code>node</code>, i.e. the reverse order of appearance in <code>node</code>'s parent's child list.</p></dd></dl></section><section><header><h2 id="combinators"><a href="#combinators" class="anchor"></a>Combinators</h2></header><dl><dt id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : (<span class="type-var">'a</span> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span>) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f init s</code> folds <code>f</code> over the nodes of <code>s</code>, i.e. if <code>s</code> is <code>n, n', n'', ...</code>, evaluates <code>f (f (f init n) n') n'' ...</code>.</p></dd></dl><dl><dt id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">val </span>filter : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>filter f s</code> is the sequence consisting of the nodes <code>n</code> of <code>s</code> for which <code>f n</code> evaluates to <code>true</code>.</p></dd></dl><dl><dt id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-node">node</a>) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>map f s</code> is the sequence consisting of nodes <code>f n</code> for each node <code>n</code> of <code>s</code>.</p></dd></dl><dl><dt id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span class="keyword">val </span>filter_map : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-node">node</a> option) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>filter_map f s</code> is the sequence consisting of nodes <code>n'</code> for each node <code>n</code> of <code>s</code> for which <code>f n</code> evaluates to <code>Some n'</code>. Nodes for which <code>f n</code> evaluates to <code>None</code> are dropped.</p></dd></dl><dl><dt id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val </span>flatten : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a>) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p><code>flatten f s</code> is the sequence consisting of the concatenation of all the sequences <code>f n</code> for each <code>n</code> in <code>s</code>.</p></dd></dl><dl><dt id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : (<span class="type-var">'a</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit) <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>iter f s</code> applies <code>f</code> to each node in <code>s</code>.</p></dd></dl><dl><dt id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val </span>rev : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Reverses the given node sequence. Note that this forces traversal of the sequence.</p></dd></dl><dl><dt id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val </span>to_list : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> list</code></dt><dd><p>Converts the given node sequence to a list.</p></dd></dl></section><section><header><h2 id="projection"><a href="#projection" class="anchor"></a>Projection</h2></header><dl><dt id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val </span>nth : int <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>nth n s</code> evaluates to the <code>n</code>th member of <code>s</code>, if it is present. The index is 1-based. This is for consistency with the CSS <code>:nth-child</code> selectors.</p></dd></dl><dl><dt id="val-first"><a href="#val-first" class="anchor"></a><code><span class="keyword">val </span>first : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Evaluates to the first node of the given sequence.</p></dd></dl><dl><dt id="val-last"><a href="#val-last" class="anchor"></a><code><span class="keyword">val </span>last : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Evaluates the entire given sequence and returns the last node.</p></dd></dl><dl><dt id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">val </span>count : <span class="type-var">'a</span> <a href="index.html#type-nodes">nodes</a> <span>&#8209;&gt;</span> int</code></dt><dd><p>Evaluates the entire given sequence and then returns the number of nodes.</p></dd></dl><dl><dt id="val-index_of"><a href="#val-index_of" class="anchor"></a><code><span class="keyword">val </span>index_of : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> int</code></dt><dd><p>Evaluates to the index of the given node in its parent's child list. If the node has no parent, the index is 1. The index is 1-based, according to CSS convention.</p></dd></dl><dl><dt id="val-index_of_element"><a href="#val-index_of_element" class="anchor"></a><code><span class="keyword">val </span>index_of_element : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> int</code></dt><dd><p>Evaluates to the element index of the given element in the parent's child list. That is, the index of the given element when the parent's non-element children are disregarded. The index is 1-based, according to CSS convention.</p></dd></dl></section><section><header><h2 id="convenience"><a href="#convenience" class="anchor"></a>Convenience</h2></header><dl><dt id="val-tags"><a href="#val-tags" class="anchor"></a><code><span class="keyword">val </span>tags : string <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-nodes">nodes</a></code></dt><dd><p>Evaluates to all descendant elements of the given node that have the given tag name. For example, <code>some_root_node |&gt; tags &quot;a&quot;</code> is a sequence of all <code>a</code> elements under <code>some_root_node</code>. It is equivalent to</p><pre><code>some_root_node
|&gt; descendants |&gt; elements |&gt; filter (fun e -&gt; name e = &quot;a&quot;)</code></pre><p>and</p><pre><code>some_root_node $$ &quot;a&quot;</code></pre><p>Tag names are case-insensitive.</p></dd></dl><dl><dt id="val-tag"><a href="#val-tag" class="anchor"></a><code><span class="keyword">val </span>tag : string <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <a href="index.html#val-tags"><code>tags</code></a>, but evaluates to only the first element.</p></dd></dl><dl><dt id="val-parent"><a href="#val-parent" class="anchor"></a><code><span class="keyword">val </span>parent : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Given a node, evaluates to its parent element, if it has one. Note that root nodes do not have a parent <em>element</em>, as their parent is the soup node. Equivalent to <code>n |&gt; ancestors |&gt; first</code>.</p></dd></dl><dl><dt id="val-is_root"><a href="#val-is_root" class="anchor"></a><code><span class="keyword">val </span>is_root : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node is not a soup node, and either has no parent, or its parent is a soup node.</p></dd></dl><dl><dt id="val-child"><a href="#val-child" class="anchor"></a><code><span class="keyword">val </span>child : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>child node</code> evaluates to <code>node</code>'s first child. Equivalent to <code>node |&gt; children |&gt; first</code>.</p></dd></dl><dl><dt id="val-child_element"><a href="#val-child_element" class="anchor"></a><code><span class="keyword">val </span>child_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>child_element node</code> evaluates to <code>node</code>'s first child element. Equivalent to <code>node |&gt; children |&gt; elements |&gt; first</code>.</p></dd></dl><dl><dt id="val-next_sibling"><a href="#val-next_sibling" class="anchor"></a><code><span class="keyword">val </span>next_sibling : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>next_sibling node</code> is the next sibling of <code>node</code> in <code>node</code>'s parent's child list. Equivalent to <code>node |&gt; next_siblings |&gt; first</code>.</p></dd></dl><dl><dt id="val-previous_sibling"><a href="#val-previous_sibling" class="anchor"></a><code><span class="keyword">val </span>previous_sibling : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <a href="index.html#val-next_sibling"><code>next_sibling</code></a>, but for the preceding sibling instead.</p></dd></dl><dl><dt id="val-next_element"><a href="#val-next_element" class="anchor"></a><code><span class="keyword">val </span>next_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p><code>next_element node</code> is the next sibling of <code>node</code> that is an element. Equivalent to <code>n |&gt; next_siblings |&gt; elements |&gt; first</code>.</p></dd></dl><dl><dt id="val-previous_element"><a href="#val-previous_element" class="anchor"></a><code><span class="keyword">val </span>previous_element : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> option</code></dt><dd><p>Like <a href="index.html#val-next_element"><code>next_element</code></a>, but for the preceding siblings instead.</p></dd></dl><dl><dt id="val-no_children"><a href="#val-no_children" class="anchor"></a><code><span class="keyword">val </span>no_children : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node has no child nodes.</p></dd></dl><dl><dt id="val-at_most_one_child"><a href="#val-at_most_one_child" class="anchor"></a><code><span class="keyword">val </span>at_most_one_child : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p>Indicates whether the given node has at most one child node.</p></dd></dl></section><section><header><h2 id="printing"><a href="#printing" class="anchor"></a>Printing</h2></header><dl><dt id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string</code></dt><dd><p>Converts the node tree rooted at the given node to an HTML5 string, preserving whitespace nodes.</p></dd></dl><dl><dt id="val-pretty_print"><a href="#val-pretty_print" class="anchor"></a><code><span class="keyword">val </span>pretty_print : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> string</code></dt><dd><p>Converts the node tree rooted at the given node to an HTML5 string formatted for easy reading by humans, difference algorthims, etc.</p><p>Note that this can change the whitespace structure of the HTML, so it may display differently in a browser than the original parsed document.</p></dd></dl></section><section><header><h2 id="parsing-signals"><a href="#parsing-signals" class="anchor"></a>Parsing signals</h2><p>Lambda Soup uses <a href="https://github.com/aantron/markup.ml">Markup.ml</a> internally to parse and write markup. If you wish to:</p><ul><li>scrape HTML output of some process without first writing it to a string,</li><li>scrape XML,</li><li>have fine control over how parsing is done, such as encoding selection, or</li><li>run the input or output of Lambda Soup through streaming filters,</li></ul><p>then you should use the functions below instead of <a href="index.html#val-parse"><code>parse</code></a> and <a href="index.html#val-to_string"><code>to_string</code></a>.</p><p>See the <a href="http://aantron.github.io/markup.ml/">Markup.ml documentation</a> for a description of the types involved. The <a href="https://github.com/aantron/markup.ml#overview-and-basic-usage">Markup.ml overview</a> may be a good place to start.</p></header><dl><dt id="val-signals"><a href="#val-signals" class="anchor"></a><code><span class="keyword">val </span>signals : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> (<a href="../../markup/Markup/index.html#type-signal">Markup.signal</a>,Â <a href="../../markup/Markup/index.html#type-sync">Markup.sync</a>)Â <a href="../../markup/Markup/index.html#type-stream">Markup.stream</a></code></dt><dd><p>Converts the node tree rooted at the given node to a stream of Markup.ml signals. This underlies <a href="index.html#val-to_string"><code>to_string</code></a> and <a href="index.html#val-pretty_print"><code>pretty_print</code></a>.</p><p>For example, you can use this function together with <a href="http://aantron.github.io/markup.ml/#VALwrite_xml"><code>Markup.write_xml</code></a> to output XML, instead of HTML:</p><pre><code>soup |&gt; signals |&gt; Markup.write_xml |&gt; Markup.to_string</code></pre></dd></dl><dl><dt id="val-from_signals"><a href="#val-from_signals" class="anchor"></a><code><span class="keyword">val </span>from_signals : (<a href="../../markup/Markup/index.html#type-signal">Markup.signal</a>,Â <a href="../../markup/Markup/index.html#type-sync">Markup.sync</a>)Â <a href="../../markup/Markup/index.html#type-stream">Markup.stream</a> <span>&#8209;&gt;</span> <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Converts a stream of Markup.ml signals to a Lambda Soup document. This underlies <a href="index.html#val-parse"><code>parse</code></a>.</p><p>For example, you can use this function together with <a href="http://aantron.github.io/markup.ml/#VALparse_xml"><code>Markup.parse_xml</code></a> to load XML into Lambda Soup:</p><pre><code>Markup.string s |&gt; Markup.parse_xml |&gt; Markup.signals |&gt; from_signals</code></pre><p>Namespaces are ignored at the moment.</p></dd></dl></section><section><header><h2 id="equality"><a href="#equality" class="anchor"></a>Equality</h2></header><dl><dt id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p><code>equal n n'</code> recursively tests the node trees rooted at <code>n</code> and <code>n'</code> for equality. To test <code>true</code>, the trees must be identical, including whitespace text nodes. Class attributes and other multi-valued attributes are compared literally: classes must be listed in the same order, with the same amount of whitespace in the attribute value. For the purposes of comparison, adjacent text nodes are merged, and empty text nodes are ignored: this is the standard HTML normalization procedure.</p></dd></dl><dl><dt id="val-equal_modulo_whitespace"><a href="#val-equal_modulo_whitespace" class="anchor"></a><code><span class="keyword">val </span>equal_modulo_whitespace : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> bool</code></dt><dd><p><code>equal_modulo_whitespace n n'</code> is like <code>equal n n'</code>, but all text nodes have their values passed through <code>String.trim</code>. Text nodes that become empty are then ignored for the purpose of comparison, as in <code>equal</code>.</p></dd></dl></section><section><header><h2 id="mutation"><a href="#mutation" class="anchor"></a>Mutation</h2></header><dl><dt id="val-create_element"><a href="#val-create_element" class="anchor"></a><code><span class="keyword">val </span>create_element : ?&#8288;id:string <span>&#8209;&gt;</span> ?&#8288;class_:string <span>&#8209;&gt;</span> ?&#8288;classes:string list <span>&#8209;&gt;</span> ?&#8288;attributes:(string<span class="keyword"> * </span>string) list <span>&#8209;&gt;</span> ?&#8288;inner_text:string <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a></code></dt><dd><p><code>create_element tag</code> creates a new element with the name <code>tag</code>.</p><p>If <code>~attributes</code> is specified, the given attributes are added to the element. <code>~attributes</code> defaults to <code>[]</code>.</p><p>If <code>~classes</code> is specified, the class names are concatenated into a single string <code>s</code> and the <code>class</code> attribute is set on the element to the resulting value. This takes precedence over <code>~attributes</code>.</p><p>If <code>~class</code> is specified, the class is set on the element. This takes precedence over both <code>~attributes</code> and <code>~classes</code>.</p><p>If <code>~id</code> is specified, the id is set. This takes precedence over <code>~attributes</code>.</p><p>If <code>~inner_text</code> is specified, a text node is created with the given string, and made the single child of the new element.</p></dd></dl><dl><dt id="val-create_text"><a href="#val-create_text" class="anchor"></a><code><span class="keyword">val </span>create_text : string <span>&#8209;&gt;</span> <a href="index.html#type-general">general</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Creates a new text node with the given content.</p></dd></dl><dl><dt id="val-create_soup"><a href="#val-create_soup" class="anchor"></a><code><span class="keyword">val </span>create_soup : unit <span>&#8209;&gt;</span> <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a></code></dt><dd><p>Creates a new empty document node.</p></dd></dl><dl><dt id="val-append_child"><a href="#val-append_child" class="anchor"></a><code><span class="keyword">val </span>append_child : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>append_child element node</code> adds <code>node</code> to the end of the child list of <code>element</code>.</p></dd></dl><dl><dt id="val-prepend_child"><a href="#val-prepend_child" class="anchor"></a><code><span class="keyword">val </span>prepend_child : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>prepend_child element node</code> adds <code>node</code> to the beginning of the child list of <code>element</code>.</p></dd></dl><dl><dt id="val-insert_at_index"><a href="#val-insert_at_index" class="anchor"></a><code><span class="keyword">val </span>insert_at_index : int <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>insert_at_index k element node</code> makes <code>node</code> the <code>k</code>th child of <code>element</code>. Note that the index is 1-based. If <code>k</code> is outside the range of current valid indices, <code>node</code> is inserted at the beginning or end of <code>element</code>'s child list.</p></dd></dl><dl><dt id="val-insert_before"><a href="#val-insert_before" class="anchor"></a><code><span class="keyword">val </span>insert_before : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>insert_before node node'</code> inserts <code>node'</code> immediately before <code>node</code> in <code>node</code>'s parent's child list.</p></dd></dl><dl><dt id="val-insert_after"><a href="#val-insert_after" class="anchor"></a><code><span class="keyword">val </span>insert_after : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>insert_after node node'</code> inserts <code>node'</code> immediately after <code>node</code> in <code>node</code>'s parent's child list.</p></dd></dl><dl><dt id="val-delete"><a href="#val-delete" class="anchor"></a><code><span class="keyword">val </span>delete : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p>Deletes the given node by unlinking it from its parent. If the node has descendants, they are implicitly deleted by this operation as well, in the sense that they become unreachable from the parent.</p></dd></dl><dl><dt id="val-clear"><a href="#val-clear" class="anchor"></a><code><span class="keyword">val </span>clear : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p>Unlinks all children of the given node.</p></dd></dl><dl><dt id="val-replace"><a href="#val-replace" class="anchor"></a><code><span class="keyword">val </span>replace : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>replace node node'</code> replaces <code>node</code> with <code>node'</code> in <code>node</code>'s parent's child list. All descendants of <code>node</code> are implicitly deleted by this operation, because they become unreachable from <code>node</code>'s parent.</p></dd></dl><dl><dt id="val-swap"><a href="#val-swap" class="anchor"></a><code><span class="keyword">val </span>swap : <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>swap element element'</code> replaces <code>element</code> with <code>element'</code> in <code>element</code>'s parent's child list. All children of <code>element</code> are transferred to <code>element'</code>, and all original children of <code>element'</code> are transferred to <code>element</code>.</p></dd></dl><dl><dt id="val-wrap"><a href="#val-wrap" class="anchor"></a><code><span class="keyword">val </span>wrap : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>wrap node element</code> inserts <code>element</code> in the place of <code>node</code>, and then makes <code>node</code> <code>element</code>'s child. All original children of <code>element</code> are unlinked.</p></dd></dl><dl><dt id="val-unwrap"><a href="#val-unwrap" class="anchor"></a><code><span class="keyword">val </span>unwrap : <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>unwrap node</code> unlinks <code>node</code>, and inserts all of <code>node</code>'s children as children of <code>node</code>'s parent at the former location of <code>node</code>.</p></dd></dl><dl><dt id="val-append_root"><a href="#val-append_root" class="anchor"></a><code><span class="keyword">val </span>append_root : <a href="index.html#type-soup">soup</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> <span class="type-var">_</span> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>append_root soup node</code> adds <code>node</code> as the last root node of <code>soup</code>.</p></dd></dl><dl><dt id="val-set_name"><a href="#val-set_name" class="anchor"></a><code><span class="keyword">val </span>set_name : string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p>Sets the tag name of the given element.</p></dd></dl><dl><dt id="val-set_attribute"><a href="#val-set_attribute" class="anchor"></a><code><span class="keyword">val </span>set_attribute : string <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>set_attribute attr value element</code> sets the value of attribute <code>attr</code> on <code>element</code> to <code>value</code>. If the attribute is not present, it is added to <code>element</code>. If it is already present, the value is replaced.</p></dd></dl><dl><dt id="val-delete_attribute"><a href="#val-delete_attribute" class="anchor"></a><code><span class="keyword">val </span>delete_attribute : string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p>Removes the given attribute from the given element. If the attribute is not present, has no effect.</p></dd></dl><dl><dt id="val-add_class"><a href="#val-add_class" class="anchor"></a><code><span class="keyword">val </span>add_class : string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>add_class c element</code> adds class <code>c</code> to <code>element</code>, if <code>element</code> does not already have class <code>c</code>.</p></dd></dl><dl><dt id="val-remove_class"><a href="#val-remove_class" class="anchor"></a><code><span class="keyword">val </span>remove_class : string <span>&#8209;&gt;</span> <a href="index.html#type-element">element</a> <a href="index.html#type-node">node</a> <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>remove_class c element</code> removes class <code>c</code> from <code>element</code>, if <code>element</code> has class <code>c</code>.</p></dd></dl></section><section><header><h2 id="i/o"><a href="#i/o" class="anchor"></a>I/O</h2><p>Lambda Soup is not an I/O library. However, it provides a few simple helpers based on standard I/O functions in <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#6_Inputoutput"><code>Pervasives</code></a>. These should not be used for &quot;serious&quot; code. They are only for when you need to get something done quickly, and/or don't care about corner cases, concurrency, or excellent reliability. In such cases, they allow you to avoid writing I/O wrappers or using additional libraries.</p><p>Using these, you can write little command-line scrapers and filters:</p><pre><code>let () =
  let soup = read_channel stdin |&gt; parse in
  let () = (* ...do things to soup... *) in
  soup |&gt; to_string |&gt; write_channel stdout</code></pre><p>If the above is compiled to a file <code>scrape</code>, you can then run</p><pre><code>curl -L &quot;http://location.com&quot; | ./scrape</code></pre></header><dl><dt id="val-read_file"><a href="#val-read_file" class="anchor"></a><code><span class="keyword">val </span>read_file : string <span>&#8209;&gt;</span> string</code></dt><dd><p>Reads the entire contents of the file with the given path. Raises <code>Sys_error</code> on failure.</p></dd></dl><dl><dt id="val-read_channel"><a href="#val-read_channel" class="anchor"></a><code><span class="keyword">val </span>read_channel : <a href="../../ocaml/Pervasives/index.html#type-in_channel">Pervasives.in_channel</a> <span>&#8209;&gt;</span> string</code></dt><dd><p>Reads all bytes from the given channel.</p></dd></dl><dl><dt id="val-write_file"><a href="#val-write_file" class="anchor"></a><code><span class="keyword">val </span>write_file : string <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> unit</code></dt><dd><p><code>write_file path data</code> writes <code>data</code> to the file given by <code>path</code>. If the file already exists, it is truncated (erased). If you want to append to file, use <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#VALopen_out_gen"><code>open_out_gen</code></a> with the necessary flags, and pass the resulting channel to <code>write_channel</code>. Raises <code>Sys_error</code> on failure.</p></dd></dl><dl><dt id="val-write_channel"><a href="#val-write_channel" class="anchor"></a><code><span class="keyword">val </span>write_channel : <a href="../../ocaml/Pervasives/index.html#type-out_channel">Pervasives.out_channel</a> <span>&#8209;&gt;</span> string <span>&#8209;&gt;</span> unit</code></dt><dd><p>Writes the given data to the given channel.</p></dd></dl></section></body></html>