<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast_mapper (ocaml-migrate-parsetree.Ast_407.Ast_mapper)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> â€“ package <a href="../../index.html">ocaml-migrate-parsetree</a></nav><h1>Module <code>Ast_407.Ast_mapper</code></h1></header><aside><p>The interface of a -ppx rewriter</p><p>A -ppx rewriter is a program that accepts a serialized abstract syntax tree and outputs another, possibly modified, abstract syntax tree. This module encapsulates the interface between the compiler and the -ppx rewriters, handling such details as the serialization format, forwarding of command-line flags, and storing state.</p><p><a href="index.html#type-mapper"><code>mapper</code></a> allows to implement AST rewriting using open recursion. A typical mapper would be based on <a href="index.html#val-default_mapper"><code>default_mapper</code></a>, a deep identity mapper, and will fall back on it for handling the syntax it does not modify. For example:</p><pre><code>open Asttypes
open Parsetree
open Ast_mapper

let test_mapper argv =
  { default_mapper with
    expr = fun mapper expr -&gt;
      match expr with
      | { pexp_desc = Pexp_extension ({ txt = &quot;test&quot; }, PStr [])} -&gt;
        Ast_helper.Exp.constant (Const_int 42)
      | other -&gt; default_mapper.expr mapper other; }

let () =
  register &quot;ppx_test&quot; test_mapper</code></pre><p>This -ppx rewriter, which replaces <code>[%test]</code> in expressions with the constant <code>42</code>, can be compiled using <code>ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml</code>.</p></aside></body></html>