<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>List (ocaml.List)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><header><nav><a href="../index.html">Up</a> â€“ package <a href="../index.html">ocaml</a></nav><h1>Module <code>List</code></h1><p>List operations.</p><p>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</p><p>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</p></header><dl><dt id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val </span>length : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> int</code></dt><dd><p>Return the length (number of elements) of the given list.</p></dd></dl><dl><dt id="val-compare_lengths"><a href="#val-compare_lengths" class="anchor"></a><code><span class="keyword">val </span>compare_lengths : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'b</span> list <span>&#8209;&gt;</span> int</code></dt><dd><p>Compare the lengths of two lists. <code>compare_lengths l1 l2</code> is equivalent to <code>compare (length l1) (length l2)</code>, except that the computation stops after itering on the shortest list.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt id="val-compare_length_with"><a href="#val-compare_length_with" class="anchor"></a><code><span class="keyword">val </span>compare_length_with : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> int <span>&#8209;&gt;</span> int</code></dt><dd><p>Compare the length of a list to an integer. <code>compare_length_with l n</code> is equivalent to <code>compare (length l) n</code>, except that the computation stops after at most <code>n</code> iterations on the list.</p><dl><dt>since</dt><dd>4.05.0</dd></dl></dd></dl><dl><dt id="val-cons"><a href="#val-cons" class="anchor"></a><code><span class="keyword">val </span>cons : <span class="type-var">'a</span> <span>&#8209;&gt;</span> <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>cons x xs</code> is <code>x :: xs</code></p><dl><dt>since</dt><dd>4.03.0</dd></dl></dd></dl><dl><dt id="val-hd"><a href="#val-hd" class="anchor"></a><code><span class="keyword">val </span>hd : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the first element of the given list. Raise <code>Failure &quot;hd&quot;</code> if the list is empty.</p></dd></dl><dl><dt id="val-tl"><a href="#val-tl" class="anchor"></a><code><span class="keyword">val </span>tl : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Return the given list without its first element. Raise <code>Failure &quot;tl&quot;</code> if the list is empty.</p></dd></dl><dl><dt id="val-nth"><a href="#val-nth" class="anchor"></a><code><span class="keyword">val </span>nth : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> int <span>&#8209;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Raise <code>Failure &quot;nth&quot;</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p></dd></dl><dl><dt id="val-nth_opt"><a href="#val-nth_opt" class="anchor"></a><code><span class="keyword">val </span>nth_opt : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> int <span>&#8209;&gt;</span> <span class="type-var">'a</span> option</code></dt><dd><p>Return the <code>n</code>-th element of the given list. The first element (head of the list) is at position 0. Return <code>None</code> if the list is too short. Raise <code>Invalid_argument &quot;List.nth&quot;</code> if <code>n</code> is negative.</p><dl><dt>since</dt><dd>4.05</dd></dl></dd></dl><dl><dt id="val-rev"><a href="#val-rev" class="anchor"></a><code><span class="keyword">val </span>rev : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>List reversal.</p></dd></dl><dl><dt id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val </span>init : int <span>&#8209;&gt;</span> (int <span>&#8209;&gt;</span> <span class="type-var">'a</span>) <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>List.init len f</code> is <code>f 0; f 1; ...; f (len-1)</code>, evaluated left to right.</p><dl><dt>raises Invalid_argument</dt><dd><p>if len &lt; 0.</p></dd></dl><dl><dt>since</dt><dd>4.06.0</dd></dl></dd></dl><dl><dt id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val </span>append : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Concatenate two lists. Same as the infix operator <code>@</code>. Not tail-recursive (length of the first argument).</p></dd></dl><dl><dt id="val-rev_append"><a href="#val-rev_append" class="anchor"></a><code><span class="keyword">val </span>rev_append : <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p><code>List.rev_append l1 l2</code> reverses <code>l1</code> and concatenates it to <code>l2</code>. This is equivalent to <a href="index.html#val-rev"><code>List.rev</code></a><code> l1 @ l2</code>, but <code>rev_append</code> is tail-recursive and more efficient.</p></dd></dl><dl><dt id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val </span>concat : <span class="type-var">'a</span> list list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p></dd></dl><dl><dt id="val-flatten"><a href="#val-flatten" class="anchor"></a><code><span class="keyword">val </span>flatten : <span class="type-var">'a</span> list list <span>&#8209;&gt;</span> <span class="type-var">'a</span> list</code></dt><dd><p>An alias for <code>concat</code>.</p></dd></dl></body></html>